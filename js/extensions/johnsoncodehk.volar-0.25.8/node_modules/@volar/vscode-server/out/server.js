"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@volar/shared");
const vscode_vue_languageservice_1 = require("vscode-vue-languageservice");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const node_1 = require("vscode-languageserver/node");
const configs_1 = require("./configs");
const servicesManager_1 = require("./servicesManager");
const connection = node_1.createConnection(node_1.ProposedFeatures.all);
const documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
let options;
let folders = [];
connection.onInitialize(onInitialize);
connection.onInitialized(onInitialized);
connection.onDidChangeConfiguration(() => configs_1.updateConfigs(connection));
connection.listen();
documents.listen(connection);
function onInitialize(params) {
    options = params.initializationOptions;
    folders = params.workspaceFolders
        ? params.workspaceFolders
            .map(folder => folder.uri)
            .filter(uri => uri.startsWith('file:/'))
            .map(uri => shared_1.uriToFsPath(uri))
        : [];
    const result = {
        capabilities: {
            textDocumentSync: node_1.TextDocumentSyncKind.Incremental,
        }
    };
    if (options.mode === 'api') {
        result.capabilities.workspace = {
            fileOperations: {
                willRename: {
                    filters: [
                        { pattern: { glob: '**/*.vue' } },
                        { pattern: { glob: '**/*.js' } },
                        { pattern: { glob: '**/*.ts' } },
                        { pattern: { glob: '**/*.jsx' } },
                        { pattern: { glob: '**/*.tsx' } },
                        { pattern: { glob: '**/*.json' } },
                    ]
                }
            }
        };
    }
    return result;
}
async function onInitialized() {
    let servicesManager;
    if (options.mode === 'html') {
        const noStateLs = vscode_vue_languageservice_1.getDocumentLanguageService({ typescript: shared_1.loadVscodeTypescript(options.appRoot) });
        (await Promise.resolve().then(() => require('./features/htmlFeatures'))).register(connection, documents, noStateLs);
    }
    else if (options.mode === 'api') {
        servicesManager = servicesManager_1.createServicesManager('api', shared_1.loadVscodeTypescript(options.appRoot), shared_1.loadVscodeTypescriptLocalized(options.appRoot, options.language), connection, documents, folders);
    }
    else if (options.mode === 'doc') {
        servicesManager = servicesManager_1.createServicesManager('doc', shared_1.loadVscodeTypescript(options.appRoot), shared_1.loadVscodeTypescriptLocalized(options.appRoot, options.language), connection, documents, folders, async (uri) => await connection.sendRequest(shared_1.DocumentVersionRequest.type, { uri }), async () => await connection.sendNotification(shared_1.SemanticTokensChangedNotification.type));
    }
    if (servicesManager) {
        (await Promise.resolve().then(() => require('./features/customFeatures'))).register(connection, documents, servicesManager);
        (await Promise.resolve().then(() => require('./features/lspFeatures'))).register(connection, documents, servicesManager, options.tsPlugin);
    }
    switch (options.mode) {
        case 'api':
            (await Promise.resolve().then(() => require('./registers/registerApiFeatures'))).register(connection, options.tsPlugin);
            break;
        case 'doc':
            (await Promise.resolve().then(() => require('./registers/registerDocumentFeatures'))).register(connection);
            break;
        case 'html':
            (await Promise.resolve().then(() => require('./registers/registerHtmlFeatures'))).register(connection);
            break;
    }
    connection.client.register(node_1.DidChangeConfigurationNotification.type, undefined);
    configs_1.updateConfigs(connection);
}
//# sourceMappingURL=server.js.map