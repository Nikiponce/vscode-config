"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared_1 = require("@volar/shared");
const vscode_vue_languageservice_1 = require("vscode-vue-languageservice");
function register(connection, documents, servicesManager, enabledTsPlugin) {
    connection.onCompletion(async (handler) => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.doComplete(handler.textDocument.uri, handler.position, handler.context, {
            tag: () => connection.sendRequest(shared_1.GetClientTarNameCaseRequest.type, {
                uri: handler.textDocument.uri
            }),
            attr: () => connection.sendRequest(shared_1.GetClientAttrNameCaseRequest.type, {
                uri: handler.textDocument.uri
            }),
        });
    });
    connection.onCompletionResolve(async (item) => {
        var _a, _b, _c;
        const uri = (_a = item.data) === null || _a === void 0 ? void 0 : _a.uri;
        if (!uri)
            return item;
        const activeSel = await connection.sendRequest(shared_1.ActiveSelectionRequest.type);
        const newOffset = (activeSel === null || activeSel === void 0 ? void 0 : activeSel.uri.toLowerCase()) === uri.toLowerCase() ? activeSel === null || activeSel === void 0 ? void 0 : activeSel.offset : undefined;
        return (_c = (_b = servicesManager.getMatchService(uri)) === null || _b === void 0 ? void 0 : _b.doCompletionResolve(item, newOffset)) !== null && _c !== void 0 ? _c : item;
    });
    connection.onHover(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.doHover(handler.textDocument.uri, handler.position);
    });
    connection.onSignatureHelp(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.getSignatureHelp(handler.textDocument.uri, handler.position);
    });
    connection.onSelectionRanges(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.getSelectionRanges(handler.textDocument.uri, handler.positions);
    });
    connection.onPrepareRename(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.prepareRename(handler.textDocument.uri, handler.position);
    });
    connection.onRenameRequest(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.doRename(handler.textDocument.uri, handler.position, handler.newName);
    });
    connection.onCodeLens(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.getCodeLens(handler.textDocument.uri);
    });
    connection.onCodeLensResolve(codeLens => {
        var _a, _b, _c;
        const uri = (_a = codeLens.data) === null || _a === void 0 ? void 0 : _a.uri;
        return (_c = (_b = servicesManager
            .getMatchService(uri)) === null || _b === void 0 ? void 0 : _b.doCodeLensResolve(codeLens)) !== null && _c !== void 0 ? _c : codeLens;
    });
    connection.onExecuteCommand(handler => {
        var _a, _b;
        const uri = (_a = handler.arguments) === null || _a === void 0 ? void 0 : _a[0];
        return (_b = servicesManager
            .getMatchService(uri)) === null || _b === void 0 ? void 0 : _b.__internal__.executeCommand(uri, handler.command, handler.arguments, connection);
    });
    connection.onCodeAction(handler => {
        var _a;
        const uri = handler.textDocument.uri;
        const tsConfig = servicesManager.getMatchTsConfig(uri);
        const service = tsConfig ? (_a = servicesManager.services.get(tsConfig)) === null || _a === void 0 ? void 0 : _a.getLanguageService() : undefined;
        if (service) {
            const codeActions = service.getCodeActions(uri, handler.range, handler.context);
            for (const codeAction of codeActions) {
                if (codeAction.data && typeof codeAction.data === 'object') {
                    codeAction.data.tsConfig = tsConfig;
                }
                else {
                    codeAction.data = { tsConfig };
                }
            }
            return codeActions;
        }
    });
    connection.onCodeActionResolve(codeAction => {
        var _a, _b;
        const tsConfig = (_a = codeAction.data) === null || _a === void 0 ? void 0 : _a.tsConfig;
        const service = tsConfig ? (_b = servicesManager.services.get(tsConfig)) === null || _b === void 0 ? void 0 : _b.getLanguageService() : undefined;
        if (service) {
            return service.doCodeActionResolve(codeAction);
        }
        return codeAction;
    });
    connection.onReferences(handler => {
        var _a, _b;
        const result = (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findReferences(handler.textDocument.uri, handler.position);
        if (enabledTsPlugin && ((_b = documents.get(handler.textDocument.uri)) === null || _b === void 0 ? void 0 : _b.languageId) !== 'vue') {
            return result === null || result === void 0 ? void 0 : result.filter(loc => loc.uri.endsWith('.vue'));
        }
        return result;
    });
    connection.onDefinition(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findDefinition(handler.textDocument.uri, handler.position);
    });
    connection.onTypeDefinition(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findTypeDefinition(handler.textDocument.uri, handler.position);
    });
    connection.onDocumentColor(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findDocumentColors(handler.textDocument.uri);
    });
    connection.onColorPresentation(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.getColorPresentations(handler.textDocument.uri, handler.color, handler.range);
    });
    connection.onDocumentHighlight(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findDocumentHighlights(handler.textDocument.uri, handler.position);
    });
    connection.onDocumentSymbol(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findDocumentSymbols(handler.textDocument.uri);
    });
    connection.onDocumentLinks(handler => {
        var _a;
        return (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.findDocumentLinks(handler.textDocument.uri);
    });
    connection.languages.callHierarchy.onPrepare(handler => {
        var _a;
        const items = (_a = servicesManager
            .getMatchService(handler.textDocument.uri)) === null || _a === void 0 ? void 0 : _a.callHierarchy.doPrepare(handler.textDocument.uri, handler.position);
        return (items === null || items === void 0 ? void 0 : items.length) ? items : null;
    });
    connection.languages.callHierarchy.onIncomingCalls(handler => {
        var _a, _b;
        const { uri } = handler.item.data;
        return (_b = (_a = servicesManager
            .getMatchService(uri)) === null || _a === void 0 ? void 0 : _a.callHierarchy.getIncomingCalls(handler.item)) !== null && _b !== void 0 ? _b : [];
    });
    connection.languages.callHierarchy.onOutgoingCalls(handler => {
        var _a, _b;
        const { uri } = handler.item.data;
        return (_b = (_a = servicesManager
            .getMatchService(uri)) === null || _a === void 0 ? void 0 : _a.callHierarchy.getOutgoingCalls(handler.item)) !== null && _b !== void 0 ? _b : [];
    });
    connection.workspace.onWillRenameFiles(handler => {
        const edits = handler.files
            .map(file => {
            var _a;
            return (_a = servicesManager.getMatchService(file.oldUri)) === null || _a === void 0 ? void 0 : _a.getEditsForFileRename(file.oldUri, file.newUri);
        })
            .filter(shared_1.notEmpty);
        if (edits.length) {
            const result = edits[0];
            vscode_vue_languageservice_1.margeWorkspaceEdits(result, ...edits.slice(1));
            return result;
        }
        return null;
    });
}
exports.register = register;
//# sourceMappingURL=lspFeatures.js.map