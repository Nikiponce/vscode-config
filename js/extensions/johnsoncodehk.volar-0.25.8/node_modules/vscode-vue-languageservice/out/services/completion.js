"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.eventModifiers = exports.vueTags = exports.wordPatterns = exports.triggerCharacter = void 0;
const shared_1 = require("@volar/shared");
const transforms_1 = require("@volar/transforms");
const shared_2 = require("@vue/shared");
const path = require("upath");
const emmet = require("vscode-emmet-helper");
const html = require("vscode-html-languageservice");
const vscode_languageserver_1 = require("vscode-languageserver");
const node_1 = require("vscode-languageserver/node");
const languageServices = require("../utils/languageServices");
const getEmbeddedDocument = require("./embeddedDocument");
exports.triggerCharacter = {
    typescript: [".", "\"", "'", "`", "/", "@", "<", "#"],
    html: ['<', ':', '@', '.' /* Event Modifiers */, '/' /* path completion */],
    css: ['.', '@', '/' /* path completion */],
    json: ['"', ':'],
};
exports.wordPatterns = {
    css: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@#.!])?[\w-?]+%?|[@#!.])/g,
    less: /(#?-?\d*\.\d\w*%?)|(::?[\w-]+(?=[^,{;]*[,{]))|(([@#.!])?[\w-?]+%?|[@#!.])/g,
    scss: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@$#.!])?[\w-?]+%?|[@#!$.])/g,
    postcss: /(#?-?\d*\.\d\w*%?)|(::?[\w-]*(?=[^,{;]*[,{]))|(([@$#.!])?[\w-?]+%?|[@#!$.])/g, // scss
};
exports.vueTags = [
    {
        name: 'template',
        attributes: [
            {
                name: 'lang',
                values: [
                    { name: 'html' },
                    { name: 'pug' },
                ],
            },
        ],
    },
    {
        name: 'script',
        attributes: [
            {
                name: 'lang',
                values: [
                    { name: 'js' },
                    { name: 'ts' },
                    { name: 'jsx' },
                    { name: 'tsx' },
                ],
            },
            { name: 'setup', valueSet: 'v' },
        ],
    },
    {
        name: 'style',
        attributes: [
            {
                name: 'lang',
                values: [
                    { name: 'css' },
                    { name: 'scss' },
                    { name: 'less' },
                ],
            },
            { name: 'scoped', valueSet: 'v' },
            { name: 'module', valueSet: 'v' },
        ],
    },
];
// https://v3.vuejs.org/api/directives.html#v-on
exports.eventModifiers = {
    stop: 'call event.stopPropagation().',
    prevent: 'call event.preventDefault().',
    capture: 'add event listener in capture mode.',
    self: 'only trigger handler if event was dispatched from this element.',
    // {keyAlias}: 'only trigger handler on certain keys.',
    once: 'trigger handler at most once.',
    left: 'only trigger handler for left button mouse events.',
    right: 'only trigger handler for right button mouse events.',
    middle: 'only trigger handler for middle button mouse events.',
    passive: 'attaches a DOM event with { passive: true }.',
};
function register({ sourceFiles, tsLanguageService, documentContext, vueHost }) {
    const getEmbeddedDoc = getEmbeddedDocument.register(arguments[0]);
    let cache = undefined;
    return async (uri, position, context, 
    /** internal */
    getNameCase) => {
        var _a, _b, _c, _d, _e, _f;
        const sourceFile = sourceFiles.get(uri);
        if (!sourceFile)
            return;
        if ((context === null || context === void 0 ? void 0 : context.triggerKind) === node_1.CompletionTriggerKind.TriggerForIncompleteCompletions && (cache === null || cache === void 0 ? void 0 : cache.uri) === uri) {
            if ((_a = cache.tsResult) === null || _a === void 0 ? void 0 : _a.isIncomplete) {
                cache.tsResult = getTsResult(sourceFile);
            }
            if ((_b = cache.emmetResult) === null || _b === void 0 ? void 0 : _b.isIncomplete) {
                cache.emmetResult = await getEmmetResult(sourceFile);
            }
            if ((_c = cache.cssResult) === null || _c === void 0 ? void 0 : _c.isIncomplete) {
                cache.cssResult = await getCssResult(sourceFile);
            }
            if ((_d = cache.jsonResult) === null || _d === void 0 ? void 0 : _d.isIncomplete) {
                cache.jsonResult = await getJsonResult(sourceFile);
            }
            if ((_e = cache.htmlResult) === null || _e === void 0 ? void 0 : _e.isIncomplete) {
                cache.htmlResult = await getHtmlResult(sourceFile);
            }
            if ((_f = cache.vueResult) === null || _f === void 0 ? void 0 : _f.isIncomplete) {
                cache.vueResult = await getVueResult(sourceFile);
            }
            const lists = [
                cache.tsResult,
                cache.emmetResult,
                cache.cssResult,
                cache.htmlResult,
                cache.vueResult,
            ];
            return combineResults(...lists.filter(shared_1.notEmpty));
        }
        const emmetResult = await getEmmetResult(sourceFile);
        const tsResult = getTsResult(sourceFile);
        cache = { uri, tsResult, emmetResult };
        if (tsResult)
            return emmetResult ? combineResults(tsResult, emmetResult) : tsResult;
        // precede html for support inline css service
        const cssResult = await getCssResult(sourceFile);
        cache = { uri, cssResult, emmetResult };
        if (cssResult)
            return emmetResult ? combineResults(cssResult, emmetResult) : cssResult;
        const jsonResult = await getJsonResult(sourceFile);
        cache = { uri, jsonResult, emmetResult };
        if (jsonResult)
            return emmetResult ? combineResults(jsonResult, emmetResult) : jsonResult;
        const htmlResult = await getHtmlResult(sourceFile);
        cache = { uri, htmlResult, emmetResult };
        if (htmlResult)
            return emmetResult ? combineResults(htmlResult, emmetResult) : htmlResult;
        const vueResult = await getVueResult(sourceFile);
        cache = { uri, vueResult, emmetResult };
        if (vueResult)
            return emmetResult ? combineResults(vueResult, emmetResult) : vueResult;
        cache = { uri, emmetResult };
        return emmetResult;
        function combineResults(...lists) {
            return {
                isIncomplete: lists.some(list => list.isIncomplete),
                items: lists.map(list => list.items).flat(),
            };
        }
        function getTsResult(sourceFile) {
            var _a;
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.typescript.includes(context.triggerCharacter)) {
                return result;
            }
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                const tsRanges = sourceMap.getMappedRanges(position);
                for (const tsRange of tsRanges) {
                    if (!tsRange.data.capabilities.completion)
                        continue;
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const quotePreference = tsRange.data.vueTag === 'template' ? 'single' : 'auto';
                    let tsItems = tsLanguageService.doComplete(sourceMap.mappedDocument.uri, tsRange.start, {
                        quotePreference,
                        includeCompletionsForModuleExports: ['script', 'scriptSetup'].includes((_a = tsRange.data.vueTag) !== null && _a !== void 0 ? _a : ''),
                        triggerCharacter: context === null || context === void 0 ? void 0 : context.triggerCharacter,
                    });
                    if (tsRange.data.vueTag === 'template') {
                        tsItems = tsItems.filter(tsItem => {
                            const sortText = Number(tsItem.sortText);
                            if (Number.isNaN(sortText))
                                return true;
                            if (sortText < 4)
                                return true;
                            if (shared_2.isGloballyWhitelisted(tsItem.label))
                                return true;
                            return false;
                        });
                    }
                    const vueItems = tsItems.map(tsItem => {
                        const vueItem = transforms_1.transformCompletionItem(tsItem, tsRange => sourceMap.getSourceRange(tsRange.start, tsRange.end));
                        const data = {
                            uri: uri,
                            docUri: sourceMap.mappedDocument.uri,
                            mode: 'ts',
                            tsItem: tsItem,
                        };
                        vueItem.data = data;
                        return vueItem;
                    });
                    result.items = result.items.concat(vueItems);
                }
            }
            if (result) {
                result.items = result.items.filter((result) => {
                    var _a;
                    return result.label.indexOf('__VLS_') === -1
                        && (!((_a = result.labelDetails) === null || _a === void 0 ? void 0 : _a.qualifier) || result.labelDetails.qualifier.indexOf('__VLS_') === -1);
                });
            }
            return result;
        }
        async function getHtmlResult(sourceFile) {
            var _a, _b;
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.html.includes(context.triggerCharacter)) {
                return;
            }
            let nameCases = { tag: 'both', attr: 'kebabCase' };
            if (getNameCase) {
                const clientCases = await Promise.all([
                    getNameCase.tag(),
                    getNameCase.attr(),
                ]);
                nameCases.tag = clientCases[0];
                nameCases.attr = clientCases[1];
            }
            for (const sourceMap of [...sourceFile.getHtmlSourceMaps(), ...sourceFile.getPugSourceMaps()]) {
                const componentCompletion = sourceFile.getComponentCompletionData();
                const tags = [];
                const tsItems = new Map();
                const globalAttributes = [
                    { name: 'v-if' },
                    { name: 'v-else-if' },
                    { name: 'v-else', valueSet: 'v' },
                    { name: 'v-for' },
                ];
                const slots = [];
                for (const [_componentName, { item, bind, on, slot }] of componentCompletion) {
                    const componentNames = nameCases.tag === 'kebabCase'
                        ? new Set([shared_2.hyphenate(_componentName)])
                        : nameCases.tag === 'pascalCase'
                            ? new Set([_componentName])
                            : new Set([shared_2.hyphenate(_componentName), _componentName]);
                    for (const componentName of componentNames) {
                        const attributes = componentName === '*' ? globalAttributes : [];
                        for (const prop of bind) {
                            const _name = prop.data.name;
                            const name = nameCases.attr === 'pascalCase' ? _name : shared_2.hyphenate(_name);
                            if (shared_2.hyphenate(name).startsWith('on-')) {
                                const propName = '@' + name.substr('on-'.length);
                                const propKey = componentName + ':' + propName;
                                attributes.push({
                                    name: propName,
                                    description: propKey,
                                });
                                tsItems.set(propKey, prop);
                            }
                            else {
                                const propName = name;
                                const propKey = componentName + ':' + propName;
                                attributes.push({
                                    name: propName,
                                    description: propKey,
                                }, {
                                    name: ':' + propName,
                                    description: propKey,
                                });
                                tsItems.set(propKey, prop);
                            }
                        }
                        for (const event of on) {
                            const name = nameCases.attr === 'pascalCase' ? event.data.name : shared_2.hyphenate(event.data.name);
                            const propName = '@' + name;
                            const propKey = componentName + ':' + propName;
                            attributes.push({
                                name: propName,
                                description: propKey,
                            });
                            tsItems.set(propKey, event);
                        }
                        for (const _slot of slot) {
                            const propName = '#' + _slot.data.name;
                            const propKey = componentName + ':' + propName;
                            slots.push({
                                name: propName,
                                description: propKey,
                            });
                            tsItems.set(propKey, _slot);
                        }
                        if (componentName !== '*') {
                            tags.push({
                                name: componentName,
                                description: componentName + ':',
                                attributes,
                            });
                        }
                        if (item) {
                            tsItems.set(componentName + ':', item);
                        }
                    }
                }
                tags.push({
                    name: 'template',
                    attributes: slots,
                });
                const dataProvider = html.newHTMLDataProvider(uri, {
                    version: 1.1,
                    tags,
                    globalAttributes,
                });
                languageServices.html.setDataProviders(true, [dataProvider]);
                for (const htmlRange of sourceMap.getMappedRanges(position)) {
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const htmlResult = sourceMap.language === 'html'
                        ? await languageServices.html.doComplete2(sourceMap.mappedDocument, htmlRange.start, sourceMap.htmlDocument, documentContext)
                        : await languageServices.pug.doComplete(sourceMap.pugDocument, htmlRange.start, documentContext);
                    if (!htmlResult)
                        continue;
                    if (htmlResult.isIncomplete) {
                        result.isIncomplete = true;
                    }
                    const replacement = getReplacement(htmlResult, sourceMap.mappedDocument);
                    if (replacement) {
                        const isEvent = replacement.text.startsWith('@') || replacement.text.startsWith('v-on:');
                        const hasExt = replacement.text.includes('.');
                        if (isEvent && hasExt) {
                            const noExtText = path.trimExt(replacement.text, [], 999);
                            for (const modifier in exports.eventModifiers) {
                                const modifierDes = exports.eventModifiers[modifier];
                                const newItem = {
                                    label: modifier,
                                    filterText: noExtText + '.' + modifier,
                                    documentation: modifierDes,
                                    textEdit: {
                                        range: replacement.textEdit.range,
                                        newText: noExtText + '.' + modifier,
                                    },
                                    kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                                };
                                htmlResult.items.push(newItem);
                            }
                        }
                    }
                    let vueItems = htmlResult.items.map(htmlItem => transforms_1.transformCompletionItem(htmlItem, htmlRange => sourceMap.getSourceRange(htmlRange.start, htmlRange.end)));
                    const htmlItemsMap = new Map();
                    for (const entry of htmlResult.items) {
                        htmlItemsMap.set(entry.label, entry);
                    }
                    for (const vueItem of vueItems) {
                        const documentation = typeof vueItem.documentation === 'string' ? vueItem.documentation : (_a = vueItem.documentation) === null || _a === void 0 ? void 0 : _a.value;
                        const tsItem = documentation ? tsItems.get(documentation) : undefined;
                        if (tsItem) {
                            vueItem.documentation = undefined;
                        }
                        if ((vueItem.label.startsWith(':') || vueItem.label.startsWith('@'))
                            && !(documentation === null || documentation === void 0 ? void 0 : documentation.startsWith('*:')) // not globalAttributes
                        ) {
                            vueItem.sortText = '\u0000' + vueItem.sortText;
                            if (tsItem) {
                                vueItem.kind = vscode_languageserver_1.CompletionItemKind.Field;
                            }
                        }
                        else if (vueItem.label.startsWith('v-')) {
                            vueItem.kind = vscode_languageserver_1.CompletionItemKind.Method;
                            vueItem.sortText = '\u0002' + vueItem.sortText;
                        }
                        else {
                            vueItem.sortText = '\u0001' + vueItem.sortText;
                        }
                        const data = {
                            mode: 'html',
                            uri: uri,
                            docUri: sourceMap.mappedDocument.uri,
                            tsItem: tsItem,
                        };
                        vueItem.data = data;
                    }
                    { // filter HTMLAttributes
                        const temp = new Map();
                        for (const item of vueItems) {
                            if (!((_b = temp.get(item.label)) === null || _b === void 0 ? void 0 : _b.documentation)) {
                                temp.set(item.label, item);
                            }
                        }
                        vueItems = [...temp.values()];
                    }
                    result.items = result.items.concat(vueItems);
                }
            }
            return result;
        }
        async function getCssResult(sourceFile) {
            var _a;
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.css.includes(context.triggerCharacter)) {
                return;
            }
            for (const sourceMap of sourceFile.getCssSourceMaps()) {
                const cssRanges = sourceMap.getMappedRanges(position);
                for (const cssRange of cssRanges) {
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const cssLanguageService = languageServices.getCssLanguageService(sourceMap.mappedDocument.languageId);
                    if (!cssLanguageService || !sourceMap.stylesheet)
                        continue;
                    const wordPattern = (_a = exports.wordPatterns[sourceMap.mappedDocument.languageId]) !== null && _a !== void 0 ? _a : exports.wordPatterns.css;
                    const wordStart = shared_1.getWordStart(wordPattern, cssRange.end, sourceMap.mappedDocument);
                    const wordRange = wordStart ? { start: wordStart, end: cssRange.end } : cssRange;
                    const cssResult = await cssLanguageService.doComplete2(sourceMap.mappedDocument, cssRange.start, sourceMap.stylesheet, documentContext);
                    if (cssResult.isIncomplete) {
                        result.isIncomplete = true;
                    }
                    const data = {
                        uri: uri,
                        docUri: sourceMap.mappedDocument.uri,
                        mode: 'css',
                    };
                    const vueItems = cssResult.items.map(cssItem => {
                        var _a;
                        const newText = ((_a = cssItem.textEdit) === null || _a === void 0 ? void 0 : _a.newText) || cssItem.insertText || cssItem.label;
                        cssItem.textEdit = vscode_languageserver_1.TextEdit.replace(wordRange, newText);
                        const vueItem = transforms_1.transformCompletionItem(cssItem, cssRange => sourceMap.getSourceRange(cssRange.start, cssRange.end));
                        vueItem.data = data;
                        return vueItem;
                    });
                    result.items = result.items.concat(vueItems);
                }
            }
            return result;
        }
        async function getJsonResult(sourceFile) {
            let result = undefined;
            if ((context === null || context === void 0 ? void 0 : context.triggerCharacter) && !exports.triggerCharacter.json.includes(context.triggerCharacter)) {
                return;
            }
            for (const sourceMap of sourceFile.getJsonSourceMaps()) {
                const jsonRanges = sourceMap.getMappedRanges(position);
                for (const cssRange of jsonRanges) {
                    if (!result) {
                        result = {
                            isIncomplete: false,
                            items: [],
                        };
                    }
                    const jsonLs = languageServices.json;
                    const jsonResult = await jsonLs.doComplete(sourceMap.mappedDocument, cssRange.start, sourceMap.jsonDocument);
                    if (!jsonResult)
                        continue;
                    if (jsonResult.isIncomplete) {
                        result.isIncomplete = true;
                    }
                    const vueItems = jsonResult.items.map(jsonItem => {
                        const vueItem = transforms_1.transformCompletionItem(jsonItem, jsonRange => sourceMap.getSourceRange(jsonRange.start, jsonRange.end));
                        return vueItem;
                    });
                    result.items = result.items.concat(vueItems);
                }
            }
            return result;
        }
        async function getVueResult(sourceFile) {
            const embededDoc = getEmbeddedDoc(uri, { start: position, end: position });
            if (embededDoc) {
                let syntax = shared_1.languageIdToSyntax(embededDoc.language);
                if (syntax === 'vue') {
                    const dataProvider = html.newHTMLDataProvider(uri, {
                        version: 1.1,
                        tags: exports.vueTags,
                    });
                    languageServices.html.setDataProviders(false, [dataProvider]);
                    return await languageServices.html.doComplete2(sourceFile.getTextDocument(), position, sourceFile.getVueHtmlDocument(), documentContext);
                }
            }
        }
        async function getEmmetResult(sourceFile) {
            var _a;
            if (!vueHost.getEmmetConfig)
                return;
            const embededDoc = getEmbeddedDoc(uri, { start: position, end: position });
            if (embededDoc) {
                const emmetConfig = await vueHost.getEmmetConfig(embededDoc.language);
                if (emmetConfig) {
                    let mode = emmet.getEmmetMode(embededDoc.language === 'vue' ? 'html' : embededDoc.language);
                    if (!mode)
                        return;
                    const doc = (_a = embededDoc.document) !== null && _a !== void 0 ? _a : sourceFile.getTextDocument();
                    const emmetResult = emmet.doComplete(doc, embededDoc.range.start, mode, emmetConfig);
                    if (emmetResult && embededDoc.sourceMap) {
                        return transforms_1.transformCompletionList(emmetResult, emmetRange => embededDoc.sourceMap.getSourceRange(emmetRange.start, emmetRange.end));
                    }
                    return emmetResult;
                }
            }
        }
    };
}
exports.register = register;
function getReplacement(list, doc) {
    for (const item of list.items) {
        if (item.textEdit && 'range' in item.textEdit) {
            return {
                item: item,
                textEdit: item.textEdit,
                text: doc.getText(item.textEdit.range)
            };
        }
    }
}
//# sourceMappingURL=completion.js.map