"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const transforms_1 = require("@volar/transforms");
const node_1 = require("vscode-languageserver/node");
const dedupe = require("../utils/dedupe");
const rename_1 = require("./rename");
function register({ mapper }) {
    return (uri, range, context) => {
        const tsResult = onTs(uri, range, context);
        const cssResult = onCss(uri, range, context);
        return dedupe.withCodeAction([
            ...tsResult,
            ...cssResult,
        ]);
    };
    function onTs(uri, range, context) {
        var _a;
        let result = [];
        for (const tsRange of mapper.ts.to(uri, range.start, range.end)) {
            const tsContext = {
                diagnostics: transforms_1.transformLocations(context.diagnostics, vueRange => tsRange.sourceMap ? tsRange.sourceMap.getMappedRange(vueRange.start, vueRange.end) : vueRange),
                only: context.only,
            };
            if (!((_a = tsRange.sourceMap) === null || _a === void 0 ? void 0 : _a.capabilities.codeActions))
                continue;
            let tsCodeActions = tsRange.languageService.getCodeActions(tsRange.textDocument.uri, tsRange.range, tsContext);
            if (!tsCodeActions)
                continue;
            if (tsRange.sourceMap && !tsRange.sourceMap.capabilities.organizeImports) {
                tsCodeActions = tsCodeActions.filter(codeAction => codeAction.kind !== node_1.CodeActionKind.SourceOrganizeImports
                    && codeAction.kind !== node_1.CodeActionKind.SourceFixAll);
            }
            for (const tsCodeAction of tsCodeActions) {
                if (tsCodeAction.title.indexOf('__VLS_') >= 0)
                    continue;
                const edit = tsCodeAction.edit ? rename_1.tsEditToVueEdit(tsCodeAction.edit, mapper, () => true) : undefined;
                if (tsCodeAction.edit && !edit)
                    continue;
                result.push({
                    ...tsCodeAction,
                    edit,
                });
            }
        }
        return result;
    }
    function onCss(uri, range, context) {
        const result = [];
        for (const cssRange of mapper.css.to(uri, range.start, range.end)) {
            const cssContext = {
                diagnostics: transforms_1.transformLocations(context.diagnostics, vueRange => cssRange.sourceMap.getMappedRange(vueRange.start, vueRange.end)),
                only: context.only,
            };
            const cssCodeActions = cssRange.languageService.doCodeActions2(cssRange.textDocument, cssRange.range, cssContext, cssRange.stylesheet);
            for (const cssCodeAction of cssCodeActions) {
                // TODO
                // cssCodeAction.edit?.changeAnnotations
                // cssCodeAction.edit?.documentChanges...
                if (cssCodeAction.edit) {
                    const vueEdit = {};
                    for (const cssUri in cssCodeAction.edit.changes) {
                        if (cssUri === cssRange.textDocument.uri) {
                            if (!vueEdit.changes) {
                                vueEdit.changes = {};
                            }
                            vueEdit.changes[uri] = transforms_1.transformLocations(vueEdit.changes[cssUri], cssRange_2 => cssRange.sourceMap.getSourceRange(cssRange_2.start, cssRange_2.end));
                        }
                    }
                    if (cssCodeAction.edit.documentChanges) {
                        for (const cssDocChange of cssCodeAction.edit.documentChanges) {
                            if (!vueEdit.documentChanges) {
                                vueEdit.documentChanges = [];
                            }
                            if (node_1.TextDocumentEdit.is(cssDocChange)) {
                                cssDocChange.textDocument = {
                                    uri: uri,
                                    version: cssRange.sourceMap.sourceDocument.version,
                                };
                                cssDocChange.edits = transforms_1.transformLocations(cssDocChange.edits, cssRange_2 => cssRange.sourceMap.getSourceRange(cssRange_2.start, cssRange_2.end));
                                vueEdit.documentChanges.push(cssDocChange);
                            }
                        }
                    }
                    cssCodeAction.edit = vueEdit;
                }
                if (cssCodeAction.diagnostics) {
                    cssCodeAction.diagnostics = transforms_1.transformLocations(cssCodeAction.diagnostics, cssRange_2 => cssRange.sourceMap.getSourceRange(cssRange_2.start, cssRange_2.end));
                }
                result.push(cssCodeAction);
            }
        }
        return result;
    }
}
exports.register = register;
//# sourceMappingURL=codeAction.js.map