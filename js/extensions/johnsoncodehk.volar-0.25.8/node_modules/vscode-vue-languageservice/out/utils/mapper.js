"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMapper = void 0;
const languageServices = require("../utils/languageServices");
const shared_1 = require("@volar/shared");
function createMapper(sourceFiles, tsLanguageService, getTextDocument) {
    return {
        css: {
            from: (cssUri, cssStart, cssEnd) => {
                const result = [];
                for (const [_, sourceFile] of sourceFiles) {
                    for (const sourceMap of sourceFile.getCssSourceMaps()) {
                        if (sourceMap.mappedDocument.uri === cssUri) {
                            for (const vueRange of sourceMap.getSourceRanges(cssStart, cssEnd)) {
                                result.push({
                                    sourceMap: sourceMap,
                                    textDocument: sourceMap.sourceDocument,
                                    range: vueRange,
                                });
                            }
                        }
                    }
                }
                return result;
            },
            to: (vueUri, vueStart, vueEnd) => {
                const result = [];
                const sourceFile = sourceFiles.get(vueUri);
                if (sourceFile) {
                    for (const sourceMap of sourceFile.getCssSourceMaps()) {
                        const cssLs = languageServices.getCssLanguageService(sourceMap.mappedDocument.languageId);
                        if (!cssLs || !sourceMap.stylesheet)
                            continue;
                        for (const cssRange of sourceMap.getMappedRanges(vueStart, vueEnd)) {
                            result.push({
                                sourceMap: sourceMap,
                                textDocument: sourceMap.mappedDocument,
                                stylesheet: sourceMap.stylesheet,
                                range: cssRange,
                                languageService: cssLs,
                            });
                        }
                    }
                }
                return result;
            },
        },
        html: {
            from: (htmlUri, htmlStart, htmlEnd) => {
                const result = [];
                for (const [_, sourceFile] of sourceFiles) {
                    for (const sourceMap of [...sourceFile.getHtmlSourceMaps(), ...sourceFile.getPugSourceMaps()]) {
                        if (sourceMap.mappedDocument.uri === htmlUri) {
                            for (const vueRange of sourceMap.getSourceRanges(htmlStart, htmlEnd)) {
                                result.push({
                                    textDocument: sourceMap.sourceDocument,
                                    range: vueRange,
                                });
                            }
                        }
                    }
                }
                return result;
            },
            to: (vueUri, vueStart, vueEnd) => {
                const result = [];
                const sourceFile = sourceFiles.get(vueUri);
                if (sourceFile) {
                    for (const sourceMap of sourceFile.getHtmlSourceMaps()) {
                        for (const cssRange of sourceMap.getMappedRanges(vueStart, vueEnd)) {
                            result.push({
                                language: 'html',
                                textDocument: sourceMap.mappedDocument,
                                htmlDocument: sourceMap.htmlDocument,
                                range: cssRange,
                                languageService: languageServices.html,
                            });
                        }
                    }
                    for (const sourceMap of sourceFile.getPugSourceMaps()) {
                        for (const cssRange of sourceMap.getMappedRanges(vueStart, vueEnd)) {
                            result.push({
                                language: 'pug',
                                textDocument: sourceMap.mappedDocument,
                                pugDocument: sourceMap.pugDocument,
                                range: cssRange,
                                languageService: languageServices.pug,
                            });
                        }
                    }
                }
                return result;
            },
        },
        tsUri: {
            from: (tsUri) => {
                const sourceFile = findSourceFileByTsUri(tsUri);
                if (sourceFile) {
                    return sourceFile.getTextDocument();
                }
                const document = tsLanguageService.__internal__.getTextDocument(tsUri);
                if (document) {
                    return document;
                }
            },
            to: (vueUri) => {
                const sourceFile = sourceFiles.get(vueUri);
                if (sourceFile) {
                    return {
                        languageService: tsLanguageService,
                        textDocument: sourceFile.getMainTsDoc(),
                        isVirtualFile: true,
                    };
                }
                const tsDoc = tsLanguageService.__internal__.getTextDocument(vueUri);
                if (tsDoc) {
                    return {
                        languageService: tsLanguageService,
                        textDocument: tsDoc,
                        isVirtualFile: false,
                    };
                }
            },
        },
        ts: {
            from: fromTs,
            from2: fromTs2,
            to: toTs,
            to2: toTs2,
            teleports,
            teleports2,
        },
        findSourceFileByTsUri,
    };
    function teleports(tsUri, tsStart, tsEnd) {
        const result = [];
        const sourceFile = findSourceFileByTsUri(tsUri);
        if (sourceFile) {
            const teleports = sourceFile.getTeleports();
            for (const teleport of teleports) {
                if (teleport.document.uri === tsUri) {
                    for (const teleRange of teleport.findTeleports(tsStart, tsEnd)) {
                        result.push(teleRange);
                    }
                }
            }
        }
        return result;
    }
    function teleports2(tsFsPath, tsStart, tsEnd) {
        const result = [];
        const tsUri = shared_1.fsPathToUri(tsFsPath);
        const sourceFile = findSourceFileByTsUri(tsUri);
        if (sourceFile) {
            const teleports = sourceFile.getTeleports();
            for (const teleport of teleports) {
                if (teleport.document.uri === tsUri) {
                    for (const teleRange of teleport.findTeleports2(tsStart, tsEnd)) {
                        result.push(teleRange);
                    }
                }
            }
        }
        return result;
    }
    ;
    function fromTs(tsUri, tsStart, tsEnd) {
        const tsDoc = tsLanguageService.__internal__.getTextDocument(tsUri);
        if (!tsDoc)
            return [];
        const _result = fromTs2(shared_1.uriToFsPath(tsUri), tsDoc.offsetAt(tsStart), tsEnd ? tsDoc.offsetAt(tsEnd) : undefined);
        const result = [];
        for (const r of _result) {
            result.push({
                textDocument: r.textDocument,
                range: {
                    start: r.textDocument.positionAt(r.range.start),
                    end: r.textDocument.positionAt(r.range.end),
                },
                data: r.data,
            });
        }
        return result;
    }
    ;
    function fromTs2(tsFsPath, tsStart, tsEnd) {
        tsEnd = tsEnd !== null && tsEnd !== void 0 ? tsEnd : tsStart;
        const result = [];
        const tsUri = shared_1.fsPathToUri(tsFsPath);
        const document = tsLanguageService.__internal__.getTextDocument(tsUri);
        if (!document)
            return [];
        const sourceFile = findSourceFileByTsUri(tsUri);
        if (!sourceFile) {
            result.push({
                fileName: tsFsPath,
                textDocument: document,
                range: {
                    start: tsStart,
                    end: tsEnd,
                },
            });
            return result;
        }
        for (const sourceMap of sourceFile.getTsSourceMaps()) {
            if (sourceMap.mappedDocument.uri !== tsUri)
                continue;
            for (const vueRange of sourceMap.getSourceRanges2(tsStart, tsEnd)) {
                result.push({
                    fileName: shared_1.uriToFsPath(sourceMap.sourceDocument.uri),
                    textDocument: sourceMap.sourceDocument,
                    range: vueRange,
                    data: vueRange.data,
                });
            }
        }
        return result;
    }
    ;
    function toTs(vueUri, vueStart, vueEnd) {
        const vueDoc = getTextDocument(vueUri);
        if (!vueDoc)
            return [];
        const result_2 = toTs2(shared_1.uriToFsPath(vueUri), vueDoc.offsetAt(vueStart), vueEnd ? vueDoc.offsetAt(vueEnd) : undefined);
        const result = [];
        for (const r of result_2) {
            result.push({
                sourceMap: r.sourceMap,
                textDocument: r.textDocument,
                range: {
                    start: r.textDocument.positionAt(r.range.start),
                    end: r.textDocument.positionAt(r.range.end),
                },
                data: r.data,
                languageService: tsLanguageService,
            });
        }
        return result;
    }
    function toTs2(vueFsPath, vueStart, vueEnd) {
        vueEnd = vueEnd !== null && vueEnd !== void 0 ? vueEnd : vueStart;
        const result = [];
        const sourceFile = sourceFiles.get(shared_1.fsPathToUri(vueFsPath));
        if (sourceFile) {
            for (const sourceMap of sourceFile.getTsSourceMaps()) {
                for (const tsRange of sourceMap.getMappedRanges2(vueStart, vueEnd)) {
                    result.push({
                        sourceMap: sourceMap,
                        fileName: shared_1.uriToFsPath(sourceMap.mappedDocument.uri),
                        textDocument: sourceMap.mappedDocument,
                        range: tsRange,
                        data: tsRange.data,
                        languageService: tsLanguageService.__internal__.raw,
                    });
                }
            }
        }
        else {
            const tsDoc = tsLanguageService.__internal__.getTextDocument(shared_1.fsPathToUri(vueFsPath));
            if (tsDoc) {
                result.push({
                    sourceMap: undefined,
                    fileName: shared_1.uriToFsPath(tsDoc.uri),
                    textDocument: tsDoc,
                    range: {
                        start: vueStart,
                        end: vueEnd,
                    },
                    data: {
                        vueTag: 'script',
                        capabilities: {
                            basic: true,
                            references: true,
                            definitions: true,
                            diagnostic: true,
                            formatting: true,
                            rename: true,
                            completion: true,
                            semanticTokens: true,
                            foldingRanges: true,
                            referencesCodeLens: true,
                        },
                    },
                    languageService: tsLanguageService.__internal__.raw,
                });
            }
        }
        return result;
    }
    ;
    function findSourceFileByTsUri(tsUri) {
        for (const sourceFile of sourceFiles.values()) {
            if (sourceFile.getTsDocuments().has(tsUri)) {
                return sourceFile;
            }
        }
        return undefined;
    }
}
exports.createMapper = createMapper;
//# sourceMappingURL=mapper.js.map