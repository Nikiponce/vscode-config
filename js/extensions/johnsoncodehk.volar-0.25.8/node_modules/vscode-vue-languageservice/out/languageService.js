"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = exports.getDocumentLanguageService = void 0;
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const shared_1 = require("@volar/shared");
const sourceFile_1 = require("./sourceFile");
const global_1 = require("./virtuals/global");
const reactivity_1 = require("@vue/reactivity");
const upath = require("upath");
const ts2 = require("vscode-typescript-languageservice");
const languageServices = require("./utils/languageServices");
const mapper_1 = require("./utils/mapper");
const tsPluginApis = require("./tsPluginApis");
const tsProgramApis = require("./tsProgramApis");
// vue services
const completions = require("./services/completion");
const completionResolve = require("./services/completionResolve");
const autoClose = require("./services/autoClose");
const refAutoClose = require("./services/refAutoClose");
const hover = require("./services/hover");
const diagnostics = require("./services/diagnostics");
const formatting = require("./services/formatting");
const definitions = require("./services/definition");
const references = require("./services/references");
const rename = require("./services/rename");
const codeActions = require("./services/codeAction");
const codeActionResolve = require("./services/codeActionResolve");
const documentHighlight = require("./services/documentHighlight");
const documentSymbol = require("./services/documentSymbol");
const documentLink = require("./services/documentLinks");
const documentColor = require("./services/documentColor");
const selectionRanges = require("./services/selectionRanges");
const signatureHelp = require("./services/signatureHelp");
const colorPresentations = require("./services/colorPresentation");
const semanticTokens = require("./services/semanticTokens");
const foldingRanges = require("./services/foldingRanges");
const codeLens = require("./services/codeLens");
const codeLensResolve = require("./services/codeLensResolve");
const executeCommand = require("./services/executeCommand");
const callHierarchy = require("./services/callHierarchy");
const linkedEditingRanges = require("./services/linkedEditingRange");
const tagNameCase = require("./services/tagNameCase");
const d3 = require("./services/d3");
const shared_2 = require("@volar/shared");
function getDocumentLanguageService({ typescript: ts }) {
    const cache = new Map();
    const options = {
        ts,
        getHtmlDocument,
    };
    return {
        doFormatting: formatting.register(options),
        getFoldingRanges: foldingRanges.register(options),
        doTagComplete: autoClose.register(options),
        findLinkedEditingRanges: linkedEditingRanges.register(options),
    };
    function getHtmlDocument(document) {
        const _cache = cache.get(document.uri);
        if (_cache) {
            const [cacheVersion, cacheHtmlDoc] = _cache;
            if (cacheVersion === document.version) {
                return cacheHtmlDoc;
            }
        }
        const htmlDoc = languageServices.html.parseHTMLDocument(document);
        cache.set(document.uri, [document.version, htmlDoc]);
        return htmlDoc;
    }
}
exports.getDocumentLanguageService = getDocumentLanguageService;
function createLanguageService({ typescript: ts }, vueHost, isTsPlugin = false) {
    let vueProjectVersion;
    let lastScriptVersions = new Map();
    let tsProjectVersion = 0;
    let tsProjectVersionWithoutTemplate = 0;
    let lastCompletionUpdateVersion = -1;
    const documents = new shared_2.UriMap();
    const sourceFiles = new shared_2.UriMap();
    const uriTsDocumentMap = new Map();
    const templateScriptUpdateUris = new Set();
    const initProgressCallback = [];
    const tsLanguageServiceHost = createTsLanguageServiceHost();
    const tsLanguageService = ts2.createLanguageService(tsLanguageServiceHost, ts);
    const globalDoc = global_1.getGlobalDoc(vueHost.getCurrentDirectory());
    const compilerHost = ts.createCompilerHost(vueHost.getCompilationSettings());
    const documentContext = {
        resolveReference(ref, base) {
            const resolveResult = ts.resolveModuleName(ref, base, vueHost.getCompilationSettings(), compilerHost);
            const failedLookupLocations = resolveResult.failedLookupLocations;
            const dirs = new Set();
            for (const failed of failedLookupLocations) {
                let path = failed;
                if (path.endsWith('index.d.ts')) {
                    dirs.add(path.substr(0, path.length - '/index.d.ts'.length));
                }
                if (path.endsWith('.d.ts')) {
                    path = upath.trimExt(path);
                    path = upath.trimExt(path);
                }
                else {
                    path = upath.trimExt(path);
                }
                if (ts.sys.fileExists(path) || ts.sys.fileExists(shared_1.uriToFsPath(path))) {
                    return path;
                }
            }
            for (const dir of dirs) {
                if (ts.sys.directoryExists(dir) || ts.sys.directoryExists(shared_1.uriToFsPath(dir))) {
                    return dir;
                }
            }
            return undefined;
        },
    };
    const mapper = mapper_1.createMapper(sourceFiles, tsLanguageService, getTextDocument);
    const options = {
        ts: ts,
        sourceFiles,
        tsLanguageService,
        vueHost,
        mapper,
        documentContext,
    };
    const _callHierarchy = callHierarchy.register(options);
    const findDefinition = definitions.register(options);
    const renames = rename.register(options);
    // ts plugin proxy
    const _tsPluginApis = tsPluginApis.register(options);
    const tsPlugin = {
        getSemanticDiagnostics: apiHook(tsLanguageService.__internal__.raw.getSemanticDiagnostics, false),
        getEncodedSemanticClassifications: apiHook(tsLanguageService.__internal__.raw.getEncodedSemanticClassifications, false),
        getCompletionsAtPosition: apiHook(_tsPluginApis.getCompletionsAtPosition, false),
        getCompletionEntryDetails: apiHook(tsLanguageService.__internal__.raw.getCompletionEntryDetails, false),
        getCompletionEntrySymbol: apiHook(tsLanguageService.__internal__.raw.getCompletionEntrySymbol, false),
        getQuickInfoAtPosition: apiHook(tsLanguageService.__internal__.raw.getQuickInfoAtPosition, false),
        getSignatureHelpItems: apiHook(tsLanguageService.__internal__.raw.getSignatureHelpItems, false),
        getRenameInfo: apiHook(tsLanguageService.__internal__.raw.getRenameInfo, false),
        findRenameLocations: apiHook(_tsPluginApis.findRenameLocations, true),
        getDefinitionAtPosition: apiHook(_tsPluginApis.getDefinitionAtPosition, false),
        getDefinitionAndBoundSpan: apiHook(_tsPluginApis.getDefinitionAndBoundSpan, false),
        getTypeDefinitionAtPosition: apiHook(_tsPluginApis.getTypeDefinitionAtPosition, false),
        getImplementationAtPosition: apiHook(_tsPluginApis.getImplementationAtPosition, false),
        getReferencesAtPosition: apiHook(_tsPluginApis.getReferencesAtPosition, true),
        findReferences: apiHook(_tsPluginApis.findReferences, true),
        // TODO: now is handle by vue server
        // prepareCallHierarchy: apiHook(tsLanguageService.rawLs.prepareCallHierarchy, false),
        // provideCallHierarchyIncomingCalls: apiHook(tsLanguageService.rawLs.provideCallHierarchyIncomingCalls, false),
        // provideCallHierarchyOutgoingCalls: apiHook(tsLanguageService.rawLs.provideCallHierarchyOutgoingCalls, false),
        // getEditsForFileRename: apiHook(tsLanguageService.rawLs.getEditsForFileRename, false),
        // TODO
        // getCodeFixesAtPosition: apiHook(tsLanguageService.rawLs.getCodeFixesAtPosition, false),
        // getCombinedCodeFix: apiHook(tsLanguageService.rawLs.getCombinedCodeFix, false),
        // applyCodeActionCommand: apiHook(tsLanguageService.rawLs.applyCodeActionCommand, false),
        // getApplicableRefactors: apiHook(tsLanguageService.rawLs.getApplicableRefactors, false),
        // getEditsForRefactor: apiHook(tsLanguageService.rawLs.getEditsForRefactor, false),
    };
    // ts program proxy
    const tsProgram = tsLanguageService.__internal__.raw.getProgram();
    if (!tsProgram)
        throw '!tsProgram';
    const tsProgramApis_2 = tsProgramApis.register(options);
    const tsProgramApis_3 = {
        emit: apiHook(tsProgramApis_2.emit),
        getRootFileNames: apiHook(tsProgramApis_2.getRootFileNames),
        getSemanticDiagnostics: apiHook(tsProgramApis_2.getSemanticDiagnostics),
        getSyntacticDiagnostics: apiHook(tsProgramApis_2.getSyntacticDiagnostics),
        getGlobalDiagnostics: apiHook(tsProgramApis_2.getGlobalDiagnostics),
    };
    const tsProgramProxy = new Proxy(tsProgram, {
        get: (target, property) => {
            return tsProgramApis_3[property] || target[property];
        },
    });
    return {
        doValidation: apiHook(diagnostics.register(options)),
        findDefinition: apiHook(findDefinition.on),
        findReferences: apiHook(references.register(options)),
        findTypeDefinition: apiHook(findDefinition.onType),
        callHierarchy: {
            doPrepare: apiHook(_callHierarchy.doPrepare),
            getIncomingCalls: apiHook(_callHierarchy.getIncomingCalls),
            getOutgoingCalls: apiHook(_callHierarchy.getOutgoingCalls),
        },
        prepareRename: apiHook(renames.prepareRename),
        doRename: apiHook(renames.doRename),
        getEditsForFileRename: apiHook(renames.onRenameFile, false),
        getSemanticTokens: apiHook(semanticTokens.register(options)),
        doHover: apiHook(hover.register(options), getShouldUpdateTemplateScript),
        doComplete: apiHook(completions.register(options), getShouldUpdateTemplateScript),
        getCodeActions: apiHook(codeActions.register(options), false),
        doCodeActionResolve: apiHook(codeActionResolve.register(options), false),
        doCompletionResolve: apiHook(completionResolve.register(options), false),
        doCodeLensResolve: apiHook(codeLensResolve.register(options), false),
        getSignatureHelp: apiHook(signatureHelp.register(options), false),
        getSelectionRanges: apiHook(selectionRanges.register(options), false),
        getColorPresentations: apiHook(colorPresentations.register(options), false),
        getCodeLens: apiHook(codeLens.register(options), false),
        findDocumentHighlights: apiHook(documentHighlight.register(options), false),
        findDocumentSymbols: apiHook(documentSymbol.register(options), false),
        findDocumentLinks: apiHook(documentLink.register(options), false),
        findDocumentColors: apiHook(documentColor.register(options), false),
        dispose: tsLanguageService.dispose,
        __internal__: {
            rootPath: vueHost.getCurrentDirectory(),
            tsPlugin,
            tsProgramProxy,
            onInitProgress(cb) {
                initProgressCallback.push(cb);
            },
            getTextDocument,
            checkProject: apiHook(() => {
                const vueImportErrors = tsLanguageService.doValidation(globalDoc.uri, { semantic: true });
                return !vueImportErrors.find(error => error.code === 2322); // Type 'false' is not assignable to type 'true'.ts(2322)
            }),
            getTsService: () => tsLanguageService,
            getGlobalDocs: () => [globalDoc],
            getSourceFile: apiHook(getSourceFile),
            getAllSourceFiles: apiHook(getAllSourceFiles),
            getD3: apiHook(d3.register(options)),
            executeCommand: apiHook(executeCommand.register(options, references.register(options))),
            detectTagNameCase: apiHook(tagNameCase.register(options)),
            doRefAutoClose: apiHook(refAutoClose.register(options), false),
        },
    };
    function getShouldUpdateTemplateScript(uri, pos) {
        if (!isInTemplate()) {
            return false;
        }
        update(false); // update tsProjectVersionWithoutTemplate
        if (lastCompletionUpdateVersion !== tsProjectVersionWithoutTemplate) {
            lastCompletionUpdateVersion = tsProjectVersionWithoutTemplate;
            return true;
        }
        return false;
        function isInTemplate() {
            const tsRanges = mapper.ts.to(uri, pos);
            for (const tsRange of tsRanges) {
                if (tsRange.data.vueTag === 'template') {
                    return true;
                }
            }
            const htmlRanges = mapper.html.to(uri, pos);
            if (htmlRanges.length) {
                return true;
            }
            return false;
        }
    }
    function apiHook(api, shouldUpdateTemplateScript = true) {
        const handler = {
            apply: function (target, thisArg, argumentsList) {
                if (typeof shouldUpdateTemplateScript === 'boolean') {
                    update(shouldUpdateTemplateScript);
                }
                else {
                    update(shouldUpdateTemplateScript.apply(null, argumentsList));
                }
                return target.apply(thisArg, argumentsList);
            }
        };
        return new Proxy(api, handler);
    }
    function update(shouldUpdateTemplateScript) {
        var _a;
        const newVueProjectVersion = (_a = vueHost.getProjectVersion) === null || _a === void 0 ? void 0 : _a.call(vueHost);
        if (newVueProjectVersion === undefined || newVueProjectVersion !== vueProjectVersion) {
            let tsFileChanged = false;
            vueProjectVersion = newVueProjectVersion;
            const oldFiles = new Set([...lastScriptVersions.keys()]);
            const newFiles = new Set([...vueHost.getScriptFileNames()]);
            const removes = [];
            const adds = [];
            const updates = [];
            for (const fileName of oldFiles) {
                if (!newFiles.has(fileName)) {
                    if (fileName.endsWith('.vue')) {
                        removes.push(fileName);
                    }
                    else {
                        tsFileChanged = true;
                    }
                    lastScriptVersions.delete(fileName);
                }
            }
            for (const fileName of newFiles) {
                if (!oldFiles.has(fileName)) {
                    if (fileName.endsWith('.vue')) {
                        adds.push(fileName);
                    }
                    else {
                        tsFileChanged = true;
                    }
                    lastScriptVersions.set(fileName, vueHost.getScriptVersion(fileName));
                }
            }
            for (const fileName of oldFiles) {
                if (newFiles.has(fileName)) {
                    const oldVersion = lastScriptVersions.get(fileName);
                    const newVersion = vueHost.getScriptVersion(fileName);
                    if (oldVersion !== newVersion) {
                        if (fileName.endsWith('.vue')) {
                            updates.push(fileName);
                        }
                        else {
                            tsFileChanged = true;
                        }
                        lastScriptVersions.set(fileName, newVersion);
                    }
                }
            }
            if (tsFileChanged) {
                updateTsProject(false);
                updates.length = 0;
                for (const fileName of oldFiles) {
                    if (newFiles.has(fileName)) {
                        if (fileName.endsWith('.vue')) {
                            updates.push(fileName);
                        }
                    }
                }
            }
            const finalUpdates = adds.concat(updates);
            if (removes.length) {
                unsetSourceFiles(removes.map(shared_1.fsPathToUri));
            }
            if (finalUpdates.length) {
                updateSourceFiles(finalUpdates.map(shared_1.fsPathToUri), shouldUpdateTemplateScript);
            }
        }
        else if (shouldUpdateTemplateScript && templateScriptUpdateUris.size) {
            updateSourceFiles([], shouldUpdateTemplateScript);
        }
    }
    function createTsLanguageServiceHost() {
        const scriptSnapshots = new Map();
        const tsHost = {
            ...vueHost,
            fileExists: vueHost.fileExists
                ? fileName => {
                    var _a, _b;
                    if (fileName.endsWith('.vue.ts')) {
                        fileName = upath.trimExt(fileName);
                        const isHostFile = vueHost.getScriptFileNames().includes(fileName);
                        const fileExists = !!((_a = vueHost.fileExists) === null || _a === void 0 ? void 0 : _a.call(vueHost, fileName));
                        if (!isHostFile && fileExists) {
                            vueProjectVersion += '-old'; // force update
                            update(false); // create virtual files
                        }
                        return fileExists;
                    }
                    else {
                        return !!((_b = vueHost.fileExists) === null || _b === void 0 ? void 0 : _b.call(vueHost, fileName));
                    }
                }
                : undefined,
            getProjectVersion: () => {
                var _a;
                reactivity_1.pauseTracking();
                const version = ((_a = vueHost.getProjectVersion) === null || _a === void 0 ? void 0 : _a.call(vueHost)) + ':' + tsProjectVersion.toString();
                reactivity_1.resetTracking();
                return version;
            },
            getScriptFileNames,
            getScriptVersion,
            getScriptSnapshot,
            readDirectory: (path, extensions, exclude, include, depth) => {
                var _a, _b;
                const result = (_b = (_a = vueHost.readDirectory) === null || _a === void 0 ? void 0 : _a.call(vueHost, path, extensions, exclude, include, depth)) !== null && _b !== void 0 ? _b : [];
                for (const [_, sourceFile] of sourceFiles) {
                    const vuePath = shared_1.uriToFsPath(sourceFile.uri);
                    const vuePath2 = upath.join(path, upath.basename(vuePath));
                    if (upath.relative(path.toLowerCase(), vuePath.toLowerCase()).startsWith('..')) {
                        continue;
                    }
                    if (!depth && vuePath.toLowerCase() === vuePath2.toLowerCase()) {
                        result.push(vuePath2);
                    }
                    else if (depth) {
                        result.push(vuePath2); // TODO: depth num
                    }
                }
                return result;
            },
        };
        return tsHost;
        function getScriptFileNames() {
            const tsFileNames = [];
            tsFileNames.push(shared_1.uriToFsPath(globalDoc.uri));
            for (const fileName of vueHost.getScriptFileNames()) {
                const uri = shared_1.fsPathToUri(fileName);
                const sourceFile = sourceFiles.get(uri);
                if (sourceFile) {
                    for (const [uri] of sourceFile.getTsDocuments()) {
                        tsFileNames.push(shared_1.uriToFsPath(uri)); // virtual .ts
                    }
                }
                if (isTsPlugin) {
                    tsFileNames.push(fileName); // .vue + .ts
                }
                else if (!sourceFile && !fileName.endsWith('.vue')) {
                    tsFileNames.push(fileName); // .ts
                }
            }
            return tsFileNames;
        }
        function getScriptVersion(fileName) {
            const uri = shared_1.fsPathToUri(fileName);
            if (uri === globalDoc.uri) {
                return globalDoc.version.toString();
            }
            let doc = uriTsDocumentMap.get(uri);
            if (doc) {
                return doc.version.toString();
            }
            return vueHost.getScriptVersion(fileName);
        }
        function getScriptSnapshot(fileName) {
            const version = getScriptVersion(fileName);
            const cache = scriptSnapshots.get(fileName);
            if (cache && cache[0] === version) {
                return cache[1];
            }
            const uri = shared_1.fsPathToUri(fileName);
            if (uri === globalDoc.uri) {
                const text = globalDoc.getText();
                const snapshot = ts.ScriptSnapshot.fromString(text);
                scriptSnapshots.set(fileName, [version, snapshot]);
                return snapshot;
            }
            for (const [_, sourceFile] of sourceFiles) {
                const doc = sourceFile.getTsDocuments().get(uri);
                if (doc) {
                    const text = doc.getText();
                    const snapshot = ts.ScriptSnapshot.fromString(text);
                    scriptSnapshots.set(fileName, [version, snapshot]);
                    return snapshot;
                }
            }
            let tsScript = vueHost.getScriptSnapshot(fileName);
            if (tsScript) {
                scriptSnapshots.set(fileName, [version, tsScript]);
                return tsScript;
            }
        }
    }
    function getTextDocument(uri) {
        const fileName = shared_1.uriToFsPath(uri);
        const version = Number(vueHost.getScriptVersion(fileName));
        if (!documents.has(uri) || documents.get(uri).version !== version) {
            const scriptSnapshot = vueHost.getScriptSnapshot(fileName);
            if (scriptSnapshot) {
                const scriptText = scriptSnapshot.getText(0, scriptSnapshot.getLength());
                const document = vscode_languageserver_textdocument_1.TextDocument.create(uri, uri.endsWith('.vue') ? 'vue' : 'typescript', version, scriptText);
                documents.set(uri, document);
            }
        }
        if (documents.has(uri)) {
            return documents.get(uri);
        }
        return tsLanguageService.__internal__.getTextDocument(uri);
    }
    function getSourceFile(uri) {
        return sourceFiles.get(uri);
    }
    function getAllSourceFiles() {
        return [...sourceFiles.values()];
    }
    function updateSourceFiles(uris, shouldUpdateTemplateScript) {
        var _a;
        let vueScriptsUpdated = false;
        let vueTemplateScriptUpdated = false;
        if (shouldUpdateTemplateScript) {
            for (const cb of initProgressCallback) {
                cb(0);
            }
        }
        for (const uri of uris) {
            const sourceFile = sourceFiles.get(uri);
            const doc = getTextDocument(uri);
            if (!doc)
                continue;
            if (!sourceFile) {
                sourceFiles.set(uri, sourceFile_1.createSourceFile(doc, tsLanguageService, ts, 'api', options.documentContext, uriTsDocumentMap));
                vueScriptsUpdated = true;
            }
            else {
                const updates = sourceFile.update(doc);
                if (updates.scriptUpdated) {
                    vueScriptsUpdated = true;
                }
                if (updates.templateScriptUpdated) {
                    vueTemplateScriptUpdated = true;
                }
            }
            templateScriptUpdateUris.add(uri);
        }
        if (vueScriptsUpdated) {
            updateTsProject(false);
        }
        if (shouldUpdateTemplateScript) {
            let currentNums = 0;
            for (const uri of templateScriptUpdateUris) {
                if ((_a = sourceFiles.get(uri)) === null || _a === void 0 ? void 0 : _a.updateTemplateScript()) {
                    vueTemplateScriptUpdated = true;
                }
                for (const cb of initProgressCallback) {
                    cb(++currentNums / templateScriptUpdateUris.size);
                }
            }
            templateScriptUpdateUris.clear();
            for (const cb of initProgressCallback) {
                cb(1);
            }
            initProgressCallback.length = 0;
        }
        if (vueTemplateScriptUpdated) {
            updateTsProject(true);
        }
    }
    function unsetSourceFiles(uris) {
        let updated = false;
        for (const uri of uris) {
            if (sourceFiles.delete(uri)) {
                updated = true;
            }
        }
        if (updated) {
            updateTsProject(false);
        }
    }
    function updateTsProject(isTemplateUpdate) {
        tsProjectVersion++;
        if (!isTemplateUpdate) {
            tsProjectVersionWithoutTemplate++;
        }
    }
}
exports.createLanguageService = createLanguageService;
//# sourceMappingURL=languageService.js.map